(defun mover (thePiece theBoard theMovelist)
  (let ((hasjumped nil) (validlist ()))
  (if (>= theMovelist 2) 
      (setf hasjumped t)
    )
  (if (piece-isKing thePiece) 
        (progn
          (let ((r (nth 0 (piece-location thePiece))) (c (nth 1 (piece-location thePiece))))
              (if (and (>= (- c 1) 0) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (<= (+ c 1) 7) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
               (if (and (<= (+ c 1) 7) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (>= (- c 1) 0) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )

               (dotimes (x (length validlist))
                (let ((item (nth x validlist)))
                (if (piece-p item)
                    (if (not (= (piece-owner item) (piece-owner thePiece))) ;;If diff teams
                        ;; (where you are going - where you are) + where you are going
                        (progn
                          (let ((r (+ (- (nth 0 (piece-location item)) (nth 0 (piece-location thePiece))) (nth 0 (piece-location item))))
                                (c (+ (- (nth 1 (piece-location item)) (nth 1 (piece-location thePiece))) (nth 1 (piece-location item)))))
                            (if (and (>= r 0) (<= r 7) (>= c 0) (<= c 7)) ;;if inside bounds
                            (if (not (piece-p (nth c (nth r theBoard))))
                                (progn 
                                  (let ((myBoard theBoard) (myMovelist theMovelist) (myPiece thePiece))
                                    (setf myMovelist (append myMovelist (list (piece-location thePiece))))
                                    (updateBoard myPiece myBoard myMovelist)
                                    (mover myPiece myBoard myMovelist)
                                    )
                                  )
                              )
                              )
                            (setf (nth x validlist) 0)
                            )
                          )
                      )
                  )
                  )
                )
              )
          )
    (if (= (piece-owner thePiece) 0)
        (progn
          (if (and (>= (- c 1) 0) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (<= (+ c 1) 7) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
          )
      (progn ;;else it must be player 1 and player one wants to go positive on rows
               (if (and (<= (+ c 1) 7) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (>= (- c 1) 0) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
        )

          )
    )
  )
          
    
  
