(defun mover (thePiece theBoard theMovelist)
  (let ((hasJumped nil) (validlist ()) (jumpCounter 0))
  (if (>= (length theMovelist) 2) 
      (setf hasjumped t)
    )
  (if (piece-isKing thePiece) 
        (progn
          (let ((r (nth 0 (piece-location thePiece))) (c (nth 1 (piece-location thePiece))))
              (if (and (>= (- c 1) 0) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (<= (+ c 1) 7) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
               (if (and (<= (+ c 1) 7) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (>= (- c 1) 0) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              )
          )
    (if (= (piece-owner thePiece) 0) ;;else (not a king)
        (progn
          (let ((r (nth 0 (piece-location thePiece))) (c (nth 1 (piece-location thePiece))))
          (if (and (>= (- c 1) 0) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (<= (+ c 1) 7) (>= (- r 1) 0))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (- r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
          (setf validlist (append validlist (list '0 '0)))
            )
          )
      (progn ;;else it must be player 1 and player one wants to go positive on rows
        (let ((r (nth 0 (piece-location thePiece))) (c (nth 1 (piece-location thePiece))))
        (setf validlist (append validlist (list '(0) '(0))))
               (if (and (<= (+ c 1) 7) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (+ c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
              (if (and (>= (- c 1) 0) (<= (+ r 1) 7))
                  (setf validlist (append validlist (list (nth (- c 1) (nth (+ r 1) theBoard)))))
                (setf validlist (append validlist (list 0)))
                )
          )
        )
          )
    )
    (dotimes (x (length validlist))
                (let ((item (nth x validlist)))
                (if (piece-p item)
                    (if (not (= (piece-owner item) (piece-owner thePiece))) ;;If diff teams
                        ;; (where you are going - where you are) + where you are going
                        (progn
                          (let ((r (+ (- (nth 0 (piece-location item)) (nth 0 (piece-location thePiece))) (nth 0 (piece-location item))))
                                (c (+ (- (nth 1 (piece-location item)) (nth 1 (piece-location thePiece))) (nth 1 (piece-location item)))))
                            (if (and (>= r 0) (<= r 7) (>= c 0) (<= c 7)) ;;if inside bounds
                            (if (not (piece-p (nth c (nth r theBoard))))
                                (progn 
                                  (let ((myBoard theBoard) (myMovelist theMovelist) (orginalLocation (piece-location thePiece))
                                        (setf jumpCounter (+ jumpCounter 1))
                                        (setf myMovelist (append myMovelist (list (piece-location thePiece))))
                                        (updateBoard thePiece myBoard myMovelist)
                                        (displayBoard theBoard)
                                        (mover thePiece myBoard myMovelist)
                                        (setf (piece-location thePiece) originalLocation)
                                    )
                                  )
                              )
                              )
                            (setf (nth x validlist) 0)
                            )
                          )
                      )
                  )
                  )
                  )
      )
    (if (and (not hasJumped) (= 0 jumpCounter))
        ;;TODO: add each move to the movelist for each nil found at this point in the validlist
        ;; else if jumpcounter = 0 and it has jumped then append the current location to theMovelist then append theMovelist to 
        ;; piece-movelist and return 0
        (dotimes (x (length validlist))  
          (let ((tempList ()))
            (if (eq nil (nth x validlist))
                (progn
                (if (= x 0)
                    (setf templist (append templist (piece-location thePiece) (list (- (nth 0 (piece-location thePiece)) 1) (- (nth 1 (piece-location thePiece)) 1))))
                  )
              (if (= x 1)
                    (setf templist (append templist (piece-location thePiece) (list (- (nth 0 (piece-location thePiece)) 1) (+ (nth 1 (piece-location thePiece)) 1))))
                       )
              (if (= x 2)
                    (setf templist (append templist (piece-location thePiece) (list (+ (nth 0 (piece-location thePiece)) 1) (+ (nth 1 (piece-location thePiece)) 1))))
                )
              (if (= x 3)
                    (setf templist (append templist (piece-location thePiece) (list (+ (nth 0 (piece-location thePiece)) 1) (- (nth 1 (piece-location thePiece)) 1))))
                       )
                  )
              )
            (setf (piece-movelist thePiece) (append (piece-movelist thePiece) templist))
            )
          )
      (if (and (= jumpCounter 0) hasJumped)
          (progn
            (setf theMovelist (append theMovelist (piece-location thePiece)))
            (setf (piece-movelist thePiece) (append (piece-movelist thePiece) theMovelist))
            )
        )
      )
    )
  )
          
    
  
